;エネミー基準
+class Learn()
	var pre_ehp: int
	var pre_php: int
	+var basenum: int
	+var sigma: float
	
	+var base_ex: list<@Base>
	+var base_ey: list<@Base>
	+var base_px: list<@Base>
	+var base_py: list<@Base>
	+var base_bpx: list<@Base>
	+var base_bpy: list<@Base>
	+var base_bex: list<@Base>
	+var base_bey: list<@Base>
	
	
	*func ctor()
		do me.pre_ehp :: 10
		do me.pre_php :: 10
		
		do me.sigma :: 100.0
		do me.basenum :: 3
		
		do me.base_ex :: #list<@Base>
		do me.base_ey :: #list<@Base>
		do me.base_px :: #list<@Base>
		do me.base_py :: #list<@Base>
		do me.base_bex :: #list<@Base>
		do me.base_bey :: #list<@Base>
		do me.base_bpx :: #list<@Base>
		do me.base_bpy :: #list<@Base>
		
		for(1, me.basenum)
			var base: @Base :: #@Base
			do me.base_ex.add(base)
			do me.base_ey.add(base)
			do me.base_px.add(base)
			do me.base_py.add(base)
			do me.base_bex.add(base)
			do me.base_bey.add(base)
			do me.base_bpx.add(base)
			do me.base_bpy.add(base)
		end for
	end func
	
	+func learn(e: \agent@Agent, p: \agent@Agent, be: list<\bullet@Bullet>, bp: list<\bullet@Bullet>): []int
		var shoot: int
		var move: int
		;now
		var bex: float :: -999.9
		var bey: float :: -999.9
		var bpx: float :: -999.9
		var bpy: float :: -999.9
		var bpm: int
		var bem: int
		if(^be <> 0)
			do be.head()
			do bem :: be.get().flag
			do bex :: be.get().x + be.get().width / 2.0
			do bey :: be.get().y + be.get().height / 2.0
		end if
		if(^bp <> 0)
			do bp.head()
			do bpm :: bp.get().flag
			do bpx :: bp.get().x + bp.get().width / 2.0
			do bpy :: bp.get().y + bp.get().height / 2.0
		end if
		;next
		var _bpm: int
		var _bem: int
		var _pxy: []float :: me.next_pos(p.moveF, p.x + p.width / 2.0, p.y + p.height / 2.0)
		var _bexy: []float
		
		if(^bp <> 0)
			do bp.head()
			do _bpm :: bpm
		else
			do _bpm :: 8
		end if
		var _bpxy: []float :: me.next_pos(_bpm, bpx, bpy)
		
		;next
		var q_max: float :: 0.0
		for move_next(0, 8)
			var _exy: []float :: me.next_pos(move_next, e.x + e.width / 2.0, e.y + e.height / 2.0)
			for shoot_next(0, 1)
				var q_next: [][]float :: #[9, 2]float
				if(bem = 8 & move_next <> 8)
					do _bem :: move_next * shoot_next + 8 * (1 - shoot_next)
				elif(bem <> 8)
					do _bem :: bem
				else
					do _bem :: 8
				end if
				do _bexy :: me.next_pos(_bem, bex, bey)
				
				;Qmaxをもとめる
				var lcount: int :: 0
				do me.base_ex.head()
				do me.base_ey.head()
				do me.base_px.head()
				do me.base_py.head()
				do me.base_bex.head()
				do me.base_bey.head()
				do me.base_bpx.head()
				do me.base_bpy.head()
				while(!me.base_ex.term())
					var base: @Base
					var theta: float
					var f: float
					;ex
					do base :: me.base_ex.get()
					do theta :: base.theta
					do f :: me.basefunc(_exy[0], \main@WIDTH $ float / (me.basenum $ float - 1.0) * lcount $ float, me.sigma * 2.0)
					do q_next[move_next][shoot_next] :+ theta * f
					if(base.q_max < f * theta | (move_next = 0 & shoot_next = 0))
						do base.q_max :: f * theta
					end if
					;ey
					do base :: me.base_ey.get()
					do theta :: base.theta
					do f :: me.basefunc(_exy[1], \main@HEIGHT $ float / (me.basenum $ float - 1.0) * lcount $ float, me.sigma)
					do q_next[move_next][shoot_next] :+ theta * f
					if(base.q_max < f * theta | (move_next = 0 & shoot_next = 0))
						do base.q_max :: f * theta
					end if
					;px
					do base :: me.base_px.get()
					do theta :: base.theta
					do f :: me.basefunc(_pxy[0], \main@WIDTH $ float / (me.basenum $ float - 1.0) * lcount $ float, me.sigma * 2.0)
					do q_next[move_next][shoot_next] :+ theta * f
					if(base.q_max < f * theta | (move_next = 0 & shoot_next = 0))
						do base.q_max :: f * theta
					end if
					;py
					do base :: me.base_py.get()
					do theta :: base.theta
					do f :: me.basefunc(_pxy[1], \main@HEIGHT $ float / (me.basenum $ float - 1.0) * lcount $ float, me.sigma)
					do q_next[move_next][shoot_next] :+ theta * f
					if(base.q_max < f * theta | (move_next = 0 & shoot_next = 0))
						do base.q_max :: f * theta
					end if
					;bex
					do base :: me.base_bex.get()
					do theta :: base.theta
					do f :: me.basefunc(_bexy[0], \main@WIDTH $ float / (me.basenum $ float - 1.0) * lcount $ float, me.sigma * 2.0)
					do q_next[move_next][shoot_next] :+ theta * f
					if(base.q_max < f * theta | (move_next = 0 & shoot_next = 0))
						do base.q_max :: f * theta
					end if
					;bey
					do base :: me.base_bey.get()
					do theta :: base.theta
					do f :: me.basefunc(_bexy[1], \main@HEIGHT $ float / (me.basenum $ float - 1.0) * lcount $ float, me.sigma)
					do q_next[move_next][shoot_next] :+ theta * f
					if(base.q_max < f * theta | (move_next = 0 & shoot_next = 0))
						do base.q_max :: f * theta
					end if
					;bpx
					do base :: me.base_bpx.get()
					do theta :: base.theta
					do f :: me.basefunc(_bpxy[0], \main@WIDTH $ float / (me.basenum $ float - 1.0) * lcount $ float, me.sigma * 2.0)
					do q_next[move_next][shoot_next] :+ theta * f
					if(base.q_max < f * theta | (move_next = 0 & shoot_next = 0))
						do base.q_max :: f * theta
					end if
					;bpy
					do base :: me.base_bpy.get()
					do theta :: base.theta
					do f :: me.basefunc(_bpxy[1], \main@HEIGHT $ float / (me.basenum $ float - 1.0) * lcount $ float, me.sigma)
					do q_next[move_next][shoot_next] :+ theta * f
					if(base.q_max < f * theta | (move_next = 0 & shoot_next = 0))
						do base.q_max :: f * theta
					end if
					
					
					do lcount :+ 1
					do me.base_ex.next()
					do me.base_ey.next()
					do me.base_px.next()
					do me.base_py.next()
					do me.base_bex.next()
					do me.base_bey.next()
					do me.base_bpx.next()
					do me.base_bpy.next()
				end while
				
				if(q_max < q_next[move_next][shoot_next] | (move_next = 0 & shoot_next = 0))
					do q_max :: q_next[move_next][shoot_next]
					;行動選択
					do move :: move_next
					do shoot :: shoot_next
				end if
			end for
		end for
		
		;now
		var r: float :: me.get_reward(e, p, bex, bey, bpx, bpy)
		
		var q: float
		var lcount: int :: 0
		do me.base_ex.head()
		do me.base_ey.head()
		do me.base_px.head()
		do me.base_py.head()
		do me.base_bex.head()
		do me.base_bey.head()
		do me.base_bpx.head()
		do me.base_bpy.head()
		while(!me.base_ex.term())
			var base: @Base
			
			;ex
			do base :: me.base_ex.get()
			do base.f :: me.basefunc(e.x + e.width / 2.0, \main@WIDTH $ float / (me.basenum $ float - 1.0) * lcount $ float, me.sigma * 2.0)
			do q :: base.f * base.theta
			do base.theta :: me.update_theta(base.theta, 0.2, 0.8, base.q_max, q, r, base.f)
			;ey
			do base :: me.base_ey.get()
			do base.f :: me.basefunc(e.y + e.height / 2.0, \main@HEIGHT $ float / (me.basenum $ float - 1.0) * lcount $ float, me.sigma)
			do q :: base.f * base.theta
			do base.theta :: me.update_theta(base.theta, 0.2, 0.8, base.q_max, q, r, base.f)
			;px
			do base :: me.base_px.get()
			do base.f :: me.basefunc(p.x + p.width / 2.0, \main@WIDTH $ float / (me.basenum $ float - 1.0) * lcount $ float, me.sigma * 2.0)
			do q :: base.f * base.theta
			do base.theta :: me.update_theta(base.theta, 0.2, 0.8, base.q_max, q, r, base.f)
			;py
			do base :: me.base_py.get()
			do base.f :: me.basefunc(p.y + p.height / 2.0, \main@HEIGHT $ float / (me.basenum $ float - 1.0) * lcount $ float, me.sigma)
			do q :: base.f * base.theta
			do base.theta :: me.update_theta(base.theta, 0.2, 0.8, base.q_max, q, r, base.f)
			;bex
			do base :: me.base_bex.get()
			do base.f :: me.basefunc(bex, \main@WIDTH $ float / (me.basenum $ float - 1.0) * lcount $ float, me.sigma * 2.0)
			do q :: base.f * base.theta
			do base.theta :: me.update_theta(base.theta, 0.2, 0.8, base.q_max, q, r, base.f)
			;bey
			do base :: me.base_bey.get()
			do base.f :: me.basefunc(bey, \main@HEIGHT $ float / (me.basenum $ float - 1.0) * lcount $ float, me.sigma)
			do q :: base.f * base.theta
			do base.theta :: me.update_theta(base.theta, 0.2, 0.8, base.q_max, q, r, base.f)
			;bpx
			do base :: me.base_bpx.get()
			do base.f :: me.basefunc(bpx, \main@WIDTH $ float / (me.basenum $ float - 1.0) * lcount $ float, me.sigma * 2.0)
			do q :: base.f * base.theta
			do base.theta :: me.update_theta(base.theta, 0.2, 0.8, base.q_max, q, r, base.f)
			;bpy
			do base :: me.base_bpy.get()
			do base.f :: me.basefunc(bpy, \main@HEIGHT $ float / (me.basenum $ float - 1.0) * lcount $ float, me.sigma)
			do q :: base.f * base.theta
			do base.theta :: me.update_theta(base.theta, 0.2, 0.8, base.q_max, q, r, base.f)
			
			
			do lcount :+ 1
			do me.base_ex.next()
			do me.base_ey.next()
			do me.base_px.next()
			do me.base_py.next()
			do me.base_bex.next()
			do me.base_bey.next()
			do me.base_bpx.next()
			do me.base_bpy.next()
		end while
		
		if(q_max = 0.0 | lib@rnd(1, 10) = 1)
			do move :: lib@rnd(0, 7)
			do shoot :: lib@rnd(0, 1)
		end if
		
		if(r <> 0.0)
			;	do dbg@print("px:\{p.x},r:\{r}\n")
		end if
		ret[move, shoot]
	end func
	
	+func update_theta(theta: float, a: float, gamma: float, q_max: float, q: float, r: float, f: float): float
		ret theta + a * (r + gamma * q_max - q) * f
	end func
	
	+func basefunc(x: float, mu: float, sigma: float): float
		ret lib@e ^ (-(x - mu) ^ 2.0 / (2.0 * sigma ^ 2.0)) * 1.0
	end func
	
	+func get_reward(e: \agent@Agent, p: \agent@Agent, bex: float, bey: float, bpx: float, bpy: float): float
		var reward: float :: 0.0
		var v: float :: 15.0 * 3.0
		var wallflag: int :: 0
		if(e.x + e.width / 2.0 < 50.0 + 1.0 | e.y + e.height / 2.0 < 50.0 + 1.0 | e.x + e.width / 2.0 > \main@WIDTH - (50.0 + 1.0) | e.y + e.height / 2.0 > \main@HEIGHT - (50.0 + 1.0))
			do wallflag :: 1
			do reward :+ -777.7
		end if
		if((p.x + p.width / 2.0 - bex).abs() < p.width / 2.0 + 25.0 + v & (p.y + p.height / 2.0 - bey).abs() < p.height / 2.0 + 25.0 + v)
			do reward :+ 55.5
		end if
		if(((e.x + e.width / 2.0 - bpx).abs() < e.width / 2.0 + 25.0 + v & (e.y + e.height / 2.0 - bpy).abs() < e.height / 2.0 + 25.0 + v) & wallflag = 0)
			do reward :+ -77.7
		end if
		
		ret reward
		
	end func
	
	+func next_pos(move: int, x: float, y: float): []float
		var x_next: float
		var y_next: float
		var v: float :: 15.0
		switch(move)
		case 0
			do x_next :: x
			do y_next :: y - v
		case 1
			do x_next :: x + v
			do y_next :: y - v
		case 2
			do x_next :: x + v
			do y_next :: y
		case 3
			do x_next :: x + v
			do y_next :: y + v
		case 4
			do x_next :: x
			do y_next :: y + v
		case 5
			do x_next :: x - v
			do y_next :: y + v
		case 6
			do x_next :: x - v
			do y_next :: y
		case 7
			do x_next :: x - v
			do y_next :: y - v
		case 8
			do x_next :: x
			do y_next :: y
		end switch
		ret[x_next, y_next]
	end func
	+func init()
		do me.pre_ehp :: 10
		do me.pre_php :: 10
	end func
	+func savefile(traincount: int, count: int, filename: []char, readcount: int)
		var savecount: int
		var savedata: []char :: ""
		if(traincount <= 100)
			do savecount :: 10
		elif(traincount <= 1000)
			do savecount :: 100
		elif(traincount <= 3000)
			do savecount :: 500
		else
			do savecount :: 1000
		end if
		
		if(count % savecount = 0)
			var handle: file@Writer :: file@makeWriter(filename ~ "_\{readcount + count}.txt", false)
			
			do me.base_ex.head()
			do me.base_ey.head()
			do me.base_px.head()
			do me.base_py.head()
			do me.base_bex.head()
			do me.base_bey.head()
			do me.base_bpx.head()
			do me.base_bpy.head()
			while(!me.base_ex.term())
				var base: @Base
				;ex
				do base :: me.base_ex.get()
				do savedata :~ "\{base.theta},"
				;ey
				do base :: me.base_ey.get()
				do savedata :~ "\{base.theta},"
				;px
				do base :: me.base_px.get()
				do savedata :~ "\{base.theta},"
				;py
				do base :: me.base_py.get()
				do savedata :~ "\{base.theta},"
				;bex
				do base :: me.base_bex.get()
				do savedata :~ "\{base.theta},"
				;bey
				do base :: me.base_bey.get()
				do savedata :~ "\{base.theta},"
				;bpx
				do base :: me.base_bpx.get()
				do savedata :~ "\{base.theta},"
				;bpy
				do base :: me.base_bpy.get()
				do savedata :~ "\{base.theta},"
				
				do me.base_ex.next()
				do me.base_ey.next()
				do me.base_px.next()
				do me.base_py.next()
				do me.base_bex.next()
				do me.base_bey.next()
				do me.base_bpx.next()
				do me.base_bpy.next()
			end while
			
			do handle.writeStr(savedata)
			
			do handle.fin()
			do \learn@resulttxt :~ "保存しました。 t=\{(lib@sysTime() $ float - \main@start_time $ float) / 1000.0 / 60.0}分\n"
			do dbg@print("保存しました\n")
		end if
	end func
	
	+func readfile(filename: []char, traincount: int)
		if(file@exist(filename ~ "_\{traincount}.txt"))
			var handle: file@Reader :: file@makeReader(filename ~ "_\{traincount}.txt")
			do handle.delimiter([',']) {区切り文字の設定}
			
			
			do me.base_ex.head()
			do me.base_ey.head()
			do me.base_px.head()
			do me.base_py.head()
			do me.base_bex.head()
			do me.base_bey.head()
			do me.base_bpx.head()
			do me.base_bpy.head()
			while(!me.base_ex.term())
				var base: @Base
				;ex
				do base :: me.base_ex.get()
				do base.theta :: handle.readFloat()
				;ey
				do base :: me.base_ey.get()
				do base.theta :: handle.readFloat()
				;px
				do base :: me.base_px.get()
				do base.theta :: handle.readFloat()
				;py
				do base :: me.base_py.get()
				do base.theta :: handle.readFloat()
				;bex
				do base :: me.base_bex.get()
				do base.theta :: handle.readFloat()
				;bey
				do base :: me.base_bey.get()
				do base.theta :: handle.readFloat()
				;bpx
				do base :: me.base_bpx.get()
				do base.theta :: handle.readFloat()
				;bpy
				do base :: me.base_bpy.get()
				do base.theta :: handle.readFloat()
				
				do me.base_ex.next()
				do me.base_ey.next()
				do me.base_px.next()
				do me.base_py.next()
				do me.base_bex.next()
				do me.base_bey.next()
				do me.base_bpx.next()
				do me.base_bpy.next()
			end while
			
			do handle.fin()
			do dbg@print("ファイル読み込み完了,t=\{(lib@sysTime() $ float - \main@start_time $ float) / 1000.0}秒\n")
			do \learn@resulttxt :~ "ファイル読み込み完了,t=\{(lib@sysTime() $ float - \main@start_time $ float) / 1000.0}秒\n"
		end if
	end func
end class

class Base()
	+var f: float
	+var theta: float
	+var q_max: float
end class
